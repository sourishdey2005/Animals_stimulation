# -*- coding: utf-8 -*-
"""butterfly.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/127ebTTav4OpJ1PPZHHOQY3lGVZiDvIrZ
"""

# No special !pip installs are required for basic animation,
# as matplotlib and numpy come pre-installed in Colab.
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# 1. Setup the figure and axis
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xlim(-3, 3)
ax.set_ylim(-3, 3)
ax.set_axis_off()
line, = ax.plot([], [], lw=2, color='darkviolet')

# 2. Define the Butterfly Curve data
theta = np.linspace(0, 12 * np.pi, 1000)
# The base "Butterfly" formula
r = np.exp(np.cos(theta)) - 2*np.cos(4*theta) + np.sin(theta/12)**5
x_base = np.sin(theta) * r
y_base = np.cos(theta) * r

# 3. Initialization function
def init():
    line.set_data([], [])
    return line,

# 4. Animation function: This changes the shape over time
def update(frame):
    # Use a sine wave to simulate the flapping wing motion
    # We multiply the x-coordinates to compress the wings
    flap_factor = np.abs(np.sin(frame / 10))
    x = x_base * flap_factor
    y = y_base
    line.set_data(x, y)
    return line,

# 5. Create the animation
# frames=100 controls length, interval=50 controls speed
ani = FuncAnimation(fig, update, frames=100, init_func=init, blit=True, interval=50)

# 6. Display in Colab
plt.close() # Prevents extra static plot from showing
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from matplotlib.collections import LineCollection
from IPython.display import HTML

# 1. Setup the figure
fig, ax = plt.subplots(figsize=(8, 8), facecolor='black')
ax.set_xlim(-4, 4)
ax.set_ylim(-4, 4)
ax.set_axis_off()

# 2. Define the Butterfly Curve data
theta = np.linspace(0, 12 * np.pi, 2000)
r = np.exp(np.cos(theta)) - 2*np.cos(4*theta) + np.sin(theta/12)**5
x_base = np.sin(theta) * r
y_base = np.cos(theta) * r

# 3. Create the line collections for glow and main wing
# We use LineCollection to allow for a color gradient along the line
points = np.array([x_base, y_base]).T.reshape(-1, 1, 2)
segments = np.concatenate([points[:-1], points[1:]], axis=1)

# Glow layer (wider, lower alpha)
glow_lc = LineCollection(segments, linewidths=6, alpha=0.3)
# Main wing layer (thinner, bright)
wing_lc = LineCollection(segments, linewidths=1.5, alpha=1.0)

ax.add_collection(glow_lc)
ax.add_collection(wing_lc)

# 4. Update function for "Real-Time" feel
def update(frame):
    # Flapping logic: non-linear flapping (faster close, slower open)
    flap_factor = np.abs(np.sin(frame / 8))

    # Update coordinates
    x_curr = x_base * flap_factor
    y_curr = y_base

    new_points = np.array([x_curr, y_curr]).T.reshape(-1, 1, 2)
    new_segments = np.concatenate([new_points[:-1], new_points[1:]], axis=1)

    # Update colors dynamically: shifting through a rainbow (HSV)
    # We create a color array based on the current frame
    colors = plt.cm.gist_rainbow(np.linspace(0, 1, len(new_segments)))
    # Shift colors based on frame to make it "shimmer"
    colors = np.roll(colors, frame * 5, axis=0)

    # Apply to both layers
    wing_lc.set_segments(new_segments)
    wing_lc.set_edgecolors(colors)

    glow_lc.set_segments(new_segments)
    glow_lc.set_edgecolors(colors)

    return wing_lc, glow_lc

# 5. Create the Animation
# interval=30 makes it 33 frames per second (smooth)
ani = FuncAnimation(fig, update, frames=200, interval=30, blit=True)

# 6. Display
plt.close()
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# 1. Setup the 3D Plot
fig = plt.figure(figsize=(10, 10), facecolor='black')
ax = fig.add_subplot(111, projection='3d')
ax.set_facecolor('black')
ax.set_axis_off()

# 2. Mathematical Foundation: The Butterfly Curve
# Higher density (3000 points) for "advanced" detail
theta = np.linspace(0, 12 * np.pi, 3000)
r = np.exp(np.cos(theta)) - 2*np.cos(4*theta) + np.sin(theta/12)**5

# Initial 2D wings (Flat on the XY plane)
x_base = np.sin(theta) * r
y_base = np.cos(theta) * r
z_base = np.zeros_like(x_base)

# 3. Create the multi-colored line (Gradient)
# We divide the theta into colors to create a "Neon shimmer"
colors = plt.cm.magma(np.linspace(0, 1, len(theta)))

# 4. Initialization: Plotting an empty line in 3D
line, = ax.plot([], [], [], lw=1.5)

# 5. Animation Function
def update(frame):
    ax.view_init(elev=20, azim=frame) # Automatically rotates the camera view

    # Flapping Logic: Calculate the angle of the wings
    # Angle goes from 0 (flat) to ~60 degrees (up)
    flap_angle = np.sin(frame / 5) * (np.pi / 3)

    # Apply 3D Rotation to the wings around the Y-axis (the body)
    # x' = x * cos(angle)
    # z' = |x| * sin(angle)  (Absolute x ensures wings flap UP together)
    x_3d = x_base * np.cos(flap_angle)
    y_3d = y_base
    z_3d = np.abs(x_base) * np.sin(flap_angle)

    # To create the "Advanced" unique look, we update the data
    # Note: 3D lines in Matplotlib don't support multi-color segments in one object easily,
    # so we update the coordinates and let the view rotation provide the depth.
    line.set_data(x_3d, y_3d)
    line.set_3d_properties(z_3d)
    line.set_color(plt.cm.cool(np.abs(np.sin(frame/10)))) # Color shifts over time

    return line,

# 6. Limits and Scale
ax.set_xlim(-3, 3)
ax.set_ylim(-3, 3)
ax.set_zlim(-2, 3)

# 7. Generate Animation
# interval=20 is very fast/smooth; frames=200 for a full rotation
ani = FuncAnimation(fig, update, frames=200, interval=20, blit=False)

# 8. Render in Colab
plt.close()
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# 1. Canvas Setup
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d')

# Styling the Grid for Portfolio visibility
ax.set_facecolor('white')
ax.grid(True, linestyle='--', alpha=0.6)
ax.set_xlabel('X Axis (Wing Width)')
ax.set_ylabel('Y Axis (Body Length)')
ax.set_zlabel('Z Axis (Flap Height)')

# 2. Mathematical Modeling
num_points = 2500
theta = np.linspace(0, 12 * np.pi, num_points)

# Base Butterfly Curve (The Shape)
r = np.exp(np.cos(theta)) - 2*np.cos(4*theta) + np.sin(theta/12)**5
x_base = np.sin(theta) * r
y_base = np.cos(theta) * r

# 3. Component Initialization
# Wings (Gradient effect using a single line that changes color)
wing_line, = ax.plot([], [], [], lw=2, color='#1a73e8', label='Wing Membrane')
# Body (Thick center line)
body_line, = ax.plot([], [], [], lw=6, color='black', alpha=0.8)
# Antennae
ant_l, = ax.plot([], [], [], lw=1, color='black')
ant_r, = ax.plot([], [], [], lw=1, color='black')

# 4. Simulation Engine
def update(frame):
    # Synchronize frame for a perfect loop (0 to 2pi)
    t = (frame / 100) * 2 * np.pi

    # a. Camera Logic: Slow rotation to show all 3 dimensions
    ax.view_init(elev=20 + 5*np.sin(t), azim=45 + frame)

    # b. Realistic Flap Physics
    # The inner wing moves first, the outer wing follows (Phase Lag)
    # Wing angle oscillates between -0.2 and 1.2 radians
    flap_angle = 0.5 + 0.7 * np.sin(t)

    # Apply 3D Transformation
    # x_3d = horizontal spread
    # z_3d = vertical lift (using absolute X to make both wings lift UP)
    x_curr = x_base * np.cos(flap_angle)
    y_curr = y_base
    # Adding a ripple effect: outer points (larger |x|) have a slight phase delay
    z_curr = np.abs(x_base) * np.sin(flap_angle + 0.1 * np.abs(x_base))

    # c. Update Wing Data
    wing_line.set_data(x_curr, y_curr)
    wing_line.set_3d_properties(z_curr)

    # d. Update Body & Head Data
    body_y = np.linspace(-1.5, 1.5, 20)
    body_line.set_data(np.zeros_like(body_y), body_y)
    body_line.set_3d_properties(np.zeros_like(body_y))

    # e. Update Antennae (Positioned at the front of the body)
    ant_theta = np.linspace(0, 1, 10)
    ant_y = 1.5 + ant_theta * 0.5
    # Left Antenna
    ant_l.set_data(-0.2 - ant_theta*0.3, ant_y)
    ant_l.set_3d_properties(0.5 + ant_theta*0.5)
    # Right Antenna
    ant_r.set_data(0.2 + ant_theta*0.3, ant_y)
    ant_r.set_3d_properties(0.5 + ant_theta*0.5)

    return wing_line, body_line, ant_l, ant_r

# 5. Set Scale
ax.set_xlim(-4, 4)
ax.set_ylim(-4, 4)
ax.set_zlim(-2, 4)

# 6. Animate and Display
# frames=100 matches our 't' calculation for a perfect loop
ani = FuncAnimation(fig, update, frames=100, interval=30, blit=True)

plt.close()
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# 1. Canvas Setup
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d')

# Styling
ax.set_facecolor('white')
ax.grid(True, linestyle='--', alpha=0.3)
ax.set_xlabel('Wing Width')
ax.set_ylabel('Body Length')
ax.set_zlabel('Flap Height')

# 2. Mathematical Modeling Constants
num_points = 2500
theta = np.linspace(0, 12 * np.pi, num_points)

# 3. Component Initialization
# Wings (Line object for the perimeter/veins)
wing_line, = ax.plot([], [], [], lw=1.5, color='#1a73e8', alpha=0.8)

# 3D Body (Using a surface plot for width/volume)
# We initialize the body as a sphere and transform it into an ellipsoid in the update
u = np.linspace(0, 2 * np.pi, 20)
v = np.linspace(0, np.pi, 20)
body_mesh = ax.plot_surface(np.array([[0]]), np.array([[0]]), np.array([[0]]), color='black')

# Antennae
ant_l, = ax.plot([], [], [], lw=1.5, color='black')
ant_r, = ax.plot([], [], [], lw=1.5, color='black')

def get_butterfly_shape(t_morph):
    """
    Morphs the butterfly shape by interpolating the frequency
    of the wing serrations (the cos(4*theta) part).
    """
    # Morphs the '4' in the original equation to a '1.5' for a softer wing shape
    morph_factor = 4.0 - 2.5 * (0.5 + 0.5 * np.sin(t_morph * 0.5))
    r = np.exp(np.cos(theta)) - 2*np.cos(morph_factor * theta) + np.sin(theta/12)**5
    return np.sin(theta) * r, np.cos(theta) * r

# 4. Simulation Engine
def update(frame):
    global body_mesh
    t = (frame / 100) * 2 * np.pi

    # a. Camera Rotation
    ax.view_init(elev=25, azim=45 + frame)

    # b. Morphing Wing Shape
    # Calculates a new x_base and y_base based on the current frame
    x_base, y_base = get_butterfly_shape(t)

    # c. Flap Physics
    flap_angle = 0.4 + 0.8 * np.sin(t)
    x_curr = x_base * np.cos(flap_angle)
    y_curr = y_base
    z_curr = np.abs(x_base) * np.sin(flap_angle)

    # d. Update Wings
    wing_line.set_data(x_curr, y_curr)
    wing_line.set_3d_properties(z_curr)

    # e. Update 3D Body (The Ellipsoid)
    # We remove the old mesh and draw a new one for the 'width' effect
    body_mesh.remove()
    # Body dimensions: x=width, y=length, z=height
    body_x = 0.15 * np.outer(np.cos(u), np.sin(v))
    body_y = 1.2 * np.outer(np.sin(u), np.sin(v))
    body_z = 0.15 * np.outer(np.ones(np.size(u)), np.cos(v))
    body_mesh = ax.plot_surface(body_x, body_y, body_z, color='#333333', antialiased=False)

    # f. Update Antennae
    ant_theta = np.linspace(0, 1, 10)
    ant_y_pos = 1.2 + ant_theta * 0.6
    ant_l.set_data(-0.1 - ant_theta * 0.4, ant_y_pos)
    ant_l.set_3d_properties(0.2 + ant_theta * 0.6)
    ant_r.set_data(0.1 + ant_theta * 0.4, ant_y_pos)
    ant_r.set_3d_properties(0.2 + ant_theta * 0.6)

    return wing_line, ant_l, ant_r

# 5. Set Scale
ax.set_xlim(-4, 4)
ax.set_ylim(-4, 4)
ax.set_zlim(-2, 4)
ax.set_axis_off() # Cleaner look for portfolio

# 6. Animate
ani = FuncAnimation(fig, update, frames=100, interval=40, blit=False)

plt.close()
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from matplotlib import cm

# 1. Canvas Setup
fig = plt.figure(figsize=(12, 10))
ax = fig.add_subplot(111, projection='3d')

# Styling the 3D environment
ax.set_facecolor('white')
ax.set_xlabel('X: Wing Span')
ax.set_ylabel('Y: Body Axis')
ax.set_zlabel('Z: Flap Elevation')

# 2. Mathematical Modeling Constants
num_theta = 200 # Angular resolution
num_r = 10     # Radial resolution (gives the wing "thickness/depth")
theta = np.linspace(0, 12 * np.pi, num_theta)
r_grid = np.linspace(0.1, 1.0, num_r)
T, R = np.meshgrid(theta, r_grid)

# 3. Component Initialization
# We use a list to hold the surface so we can clear/update it
wing_surf = [None]
body_surf = [None]

# Antennae (Static lines updated in loop)
ant_l, = ax.plot([], [], [], lw=2, color='black')
ant_r, = ax.plot([], [], [], lw=2, color='black')

def get_morphing_radius(t_morph):
    """Calculates the butterfly radius with a morphing shape factor."""
    # Oscillates the wing serration factor between 2.0 and 5.0
    morph = 3.5 + 1.5 * np.cos(t_morph * 0.3)
    # The Butterfly Curve Equation
    radius = np.exp(np.cos(T)) - 2*np.cos(morph * T) + np.sin(T/12)**5
    return radius * R  # Multiply by R grid to create surface area

# 4. Simulation Engine
def update(frame):
    # Clear previous surfaces to prevent memory lag
    if wing_surf[0] is not None:
        wing_surf[0].remove()
    if body_surf[0] is not None:
        body_surf[0].remove()

    t = (frame / 100) * 2 * np.pi

    # a. Camera Logic
    ax.view_init(elev=20 + 10*np.sin(t*0.5), azim=30 + frame)

    # b. Generate Morphing Wing Surface
    # Base coordinates
    r_val = get_morphing_radius(t)
    x_base = np.sin(T) * r_val
    y_base = np.cos(T) * r_val

    # c. Flap Physics with Depth
    # Added a slight phase shift based on the radius (outer wing flaps later)
    flap_angle = 0.6 * np.sin(t)
    x_curr = x_base * np.cos(flap_angle)
    z_curr = np.abs(x_base) * np.sin(flap_angle + 0.2 * R)
    y_curr = y_base

    # d. Render Wing Surface
    # Uses a colormap (Winter) to give the wings professional depth
    wing_surf[0] = ax.plot_surface(x_curr, y_curr, z_curr,
                                   cmap=cm.winter,
                                   alpha=0.7,
                                   antialiased=True)

    # e. Render 3D Body (Ellipsoid)
    u_b = np.linspace(0, 2 * np.pi, 15)
    v_b = np.linspace(0, np.pi, 15)
    # Body width (0.2), length (1.5), height (0.2)
    bx = 0.2 * np.outer(np.cos(u_b), np.sin(v_b))
    by = 1.5 * np.outer(np.sin(u_b), np.sin(v_b))
    bz = 0.2 * np.outer(np.ones(np.size(u_b)), np.cos(v_b))
    body_surf[0] = ax.plot_surface(bx, by, bz, color='#222222')

    # f. Update Antennae
    ant_t = np.linspace(0, 1, 10)
    # Positioning at the head (y ~ 1.5)
    ant_l.set_data([-0.1, -0.5], [1.4, 1.9])
    ant_l.set_3d_properties([0.1, 0.8])
    ant_r.set_data([0.1, 0.5], [1.4, 1.9])
    ant_r.set_3d_properties([0.1, 0.8])

    return ant_l, ant_r

# 5. Set Scale and Axis
ax.set_xlim(-4, 4)
ax.set_ylim(-4, 4)
ax.set_zlim(-3, 3)

# 6. Run Animation
ani = FuncAnimation(fig, update, frames=100, interval=50, blit=False)

plt.close()
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from matplotlib import cm

# 1. Canvas Setup
fig = plt.figure(figsize=(12, 10))
ax = fig.add_subplot(111, projection='3d')

# Styling the 3D environment
ax.set_facecolor('white')
ax.set_xlabel('X: Wing Span')
ax.set_ylabel('Y: Body Axis')
ax.set_zlabel('Z: Flap Elevation')

# 2. Mathematical Modeling Constants
num_theta = 200 # Angular resolution
num_r = 10     # Radial resolution (gives the wing "thickness/depth")
theta = np.linspace(0, 12 * np.pi, num_theta)
r_grid = np.linspace(0.1, 1.0, num_r)
T, R = np.meshgrid(theta, r_grid)

# 3. Component Initialization
# We use a list to hold the surface so we can clear/update it
wing_surf = [None]
body_surf = [None]

# Antennae (Static lines updated in loop)
ant_l, = ax.plot([], [], [], lw=2, color='black')
ant_r, = ax.plot([], [], [], lw=2, color='black')

def get_morphing_radius(t_morph):
    """Calculates the butterfly radius with a morphing shape factor."""
    # Oscillates the wing serration factor between 2.0 and 5.0
    morph = 3.5 + 1.5 * np.cos(t_morph * 0.3)
    # The Butterfly Curve Equation
    radius = np.exp(np.cos(T)) - 2*np.cos(morph * T) + np.sin(T/12)**5
    return radius * R  # Multiply by R grid to create surface area

# 4. Simulation Engine
def update(frame):
    # Clear previous surfaces to prevent memory lag
    if wing_surf[0] is not None:
        wing_surf[0].remove()
    if body_surf[0] is not None:
        body_surf[0].remove()

    t = (frame / 100) * 2 * np.pi

    # a. Camera Logic
    ax.view_init(elev=20 + 10*np.sin(t*0.5), azim=30 + frame)

    # b. Generate Morphing Wing Surface
    # Base coordinates
    r_val = get_morphing_radius(t)
    x_base = np.sin(T) * r_val
    y_base = np.cos(T) * r_val

    # c. Flap Physics with Depth
    # Added a slight phase shift based on the radius (outer wing flaps later)
    flap_angle = 0.6 * np.sin(t)
    x_curr = x_base * np.cos(flap_angle)
    z_curr = np.abs(x_base) * np.sin(flap_angle + 0.2 * R)
    y_curr = y_base

    # d. Render Wing Surface
    # Uses a colormap (Winter) to give the wings professional depth
    wing_surf[0] = ax.plot_surface(x_curr, y_curr, z_curr,
                                   cmap=cm.winter,
                                   alpha=0.7,
                                   antialiased=True)

    # e. Render 3D Body (Ellipsoid)
    u_b = np.linspace(0, 2 * np.pi, 15)
    v_b = np.linspace(0, np.pi, 15)
    # Body width (0.2), length (1.5), height (0.2)
    bx = 0.2 * np.outer(np.cos(u_b), np.sin(v_b))
    by = 1.5 * np.outer(np.sin(u_b), np.sin(v_b))
    bz = 0.2 * np.outer(np.ones(np.size(u_b)), np.cos(v_b))
    body_surf[0] = ax.plot_surface(bx, by, bz, color='#222222')

    # f. Update Antennae
    ant_t = np.linspace(0, 1, 10)
    # Positioning at the head (y ~ 1.5)
    ant_l.set_data([-0.1, -0.5], [1.4, 1.9])
    ant_l.set_3d_properties([0.1, 0.8])
    ant_r.set_data([0.1, 0.5], [1.4, 1.9])
    ant_r.set_3d_properties([0.1, 0.8])

    return ant_l, ant_r

# 5. Set Scale and Axis
ax.set_xlim(-4, 4)
ax.set_ylim(-4, 4)
ax.set_zlim(-3, 3)

# 6. Run Animation
ani = FuncAnimation(fig, update, frames=100, interval=50, blit=False)

plt.close()
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from matplotlib import cm

# 1. Canvas Setup
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d')

# Styling
ax.set_facecolor('white')
ax.set_xlabel('X: Wing Span')
ax.set_ylabel('Y: Body Axis')
ax.set_zlabel('Z: Flap Elevation')

# 2. Mathematical Modeling Constants
num_theta = 300
num_r = 12
theta = np.linspace(0, 12 * np.pi, num_theta)
r_grid = np.linspace(0.05, 1.0, num_r)
T, R = np.meshgrid(theta, r_grid)

# Containers for surfaces to allow clearing
wing_l_surf = [None]
wing_r_surf = [None]
body_surf = [None]

# 3. Component Initialization (Legs and Antennae)
# 6 legs (3 pairs)
legs = [ax.plot([], [], [], color='#111111', lw=1.5)[0] for _ in range(6)]
ant_l, = ax.plot([], [], [], lw=2, color='black')
ant_r, = ax.plot([], [], [], lw=2, color='black')

def get_geometry(t):
    """Calculates morphing wing shape and radius."""
    # Morphing: Clear transition from smooth to jagged
    morph = 3.5 + 1.5 * np.cos(t * 0.2)
    r = (np.exp(np.cos(T)) - 2*np.cos(morph * T) + np.sin(T/12)**5) * R
    return np.sin(T) * r, np.cos(T) * r

# 4. Simulation Engine
def update(frame):
    # Clear surfaces to prevent overlapping artifacts
    if wing_l_surf[0]: wing_l_surf[0].remove()
    if wing_r_surf[0]: wing_r_surf[0].remove()
    if body_surf[0]: body_surf[0].remove()

    t = (frame / 100) * 2 * np.pi

    # Camera Movement
    ax.view_init(elev=25, azim=45 + frame)

    # a. Generate Geometry
    x_base, y_base = get_geometry(t)

    # b. Realistic Flap with Parabolic Flex (Prevents overlapping)
    # The '0.3 * R' adds a phase lag so the tips flap after the base
    flap_power = 0.7 * np.sin(t * 1.5)
    z_curr = np.abs(x_base) * flap_power + (0.4 * R**2 * flap_power)

    # c. Render Wings in two halves (Improves depth sorting)
    # Left Wing (X < 0)
    wing_l_surf[0] = ax.plot_surface(x_base * (x_base < 0), y_base * (x_base < 0),
                                     z_curr * (x_base < 0), cmap=cm.winter,
                                     alpha=0.8, antialiased=True, rstride=1, cstride=10)
    # Right Wing (X > 0)
    wing_r_surf[0] = ax.plot_surface(x_base * (x_base > 0), y_base * (x_base > 0),
                                     z_curr * (x_base > 0), cmap=cm.winter,
                                     alpha=0.8, antialiased=True, rstride=1, cstride=10)

    # d. Render 3D Body
    u_b, v_b = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
    # Ellipsoid body
    bx = 0.18 * np.cos(u_b) * np.sin(v_b)
    by = 1.6 * np.sin(u_b) * np.sin(v_b)
    bz = 0.22 * np.cos(v_b) - 0.1
    body_surf[0] = ax.plot_surface(bx, by, bz, color='#111111')

    # e. Update 6 Legs (Segmented)
    leg_y_pos = [0.4, 0.0, -0.4] # Front, Middle, Back positions
    for i in range(3):
        # Left Legs
        legs[i].set_data([-0.1, -0.4], [leg_y_pos[i], leg_y_pos[i] - 0.2])
        legs[i].set_3d_properties([-0.1, -0.6 + 0.1 * np.sin(t)])
        # Right Legs
        legs[i+3].set_data([0.1, 0.4], [leg_y_pos[i], leg_y_pos[i] - 0.2])
        legs[i+3].set_3d_properties([-0.1, -0.6 + 0.1 * np.sin(t)])

    # f. Update Antennae
    ant_l.set_data([-0.1, -0.5], [1.4, 1.9])
    ant_l.set_3d_properties([0.1, 0.6])
    ant_r.set_data([0.1, 0.5], [1.4, 1.9])
    ant_r.set_3d_properties([0.1, 0.6])

    return legs + [ant_l, ant_r]

# 5. Final Setup
ax.set_xlim(-4, 4)
ax.set_ylim(-4, 4)
ax.set_zlim(-3, 3)
ax.grid(True, alpha=0.2)

ani = FuncAnimation(fig, update, frames=100, interval=50, blit=False)

plt.close()
HTML(ani.to_jshtml())

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML
from matplotlib import cm

# 1. Canvas Setup
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d')

# Styling
ax.set_facecolor('white')
ax.set_xlabel('X: Wing Span')
ax.set_ylabel('Y: Body Axis')
ax.set_zlabel('Z: Flap Elevation')

# 2. Mathematical Modeling Constants
num_theta = 300
num_r = 15 # Increased radial resolution for smoother color gradients
theta = np.linspace(0, 12 * np.pi, num_theta)
r_grid = np.linspace(0.05, 1.0, num_r)
T, R = np.meshgrid(theta, r_grid)

# Containers for surfaces
wing_l_surf = [None]
wing_r_surf = [None]
body_surf = [None]

# 3. Component Initialization (Legs and Antennae)
legs = [ax.plot([], [], [], color='#111111', lw=1.5)[0] for _ in range(6)]
ant_l, = ax.plot([], [], [], lw=2, color='black')
ant_r, = ax.plot([], [], [], lw=2, color='black')

def get_geometry(t):
    # Morphing logic
    morph = 3.5 + 1.5 * np.cos(t * 0.2)
    r = (np.exp(np.cos(T)) - 2*np.cos(morph * T) + np.sin(T/12)**5) * R
    return np.sin(T) * r, np.cos(T) * r

# 4. Simulation Engine
def update(frame):
    if wing_l_surf[0]: wing_l_surf[0].remove()
    if wing_r_surf[0]: wing_r_surf[0].remove()
    if body_surf[0]: body_surf[0].remove()

    t = (frame / 100) * 2 * np.pi
    ax.view_init(elev=25, azim=45 + frame)

    # a. Generate Geometry
    x_base, y_base = get_geometry(t)

    # b. Realistic Flap with Parabolic Flex
    flap_power = 0.7 * np.sin(t * 1.5)
    z_curr = np.abs(x_base) * flap_power + (0.4 * R**2 * flap_power)

    # c. Render Wings with Red-Yellow Colormap (cm.autumn)
    # Using 'autumn' provides a beautiful transition from Red to Yellow
    wing_l_surf[0] = ax.plot_surface(x_base * (x_base < 0), y_base * (x_base < 0),
                                     z_curr * (x_base < 0), cmap=cm.autumn,
                                     alpha=0.9, antialiased=True, rstride=1, cstride=10)

    wing_r_surf[0] = ax.plot_surface(x_base * (x_base > 0), y_base * (x_base > 0),
                                     z_curr * (x_base > 0), cmap=cm.autumn,
                                     alpha=0.9, antialiased=True, rstride=1, cstride=10)

    # d. Render 3D Body
    u_b, v_b = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
    bx = 0.18 * np.cos(u_b) * np.sin(v_b)
    by = 1.6 * np.sin(u_b) * np.sin(v_b)
    bz = 0.22 * np.cos(v_b) - 0.1
    body_surf[0] = ax.plot_surface(bx, by, bz, color='#1a1a1a', shade=True)

    # e. Update 6 Legs
    leg_y_pos = [0.4, 0.0, -0.4]
    for i in range(3):
        # Left Legs
        legs[i].set_data([-0.1, -0.4], [leg_y_pos[i], leg_y_pos[i] - 0.2])
        legs[i].set_3d_properties([-0.1, -0.6 + 0.1 * np.sin(t)])
        # Right Legs
        legs[i+3].set_data([0.1, 0.4], [leg_y_pos[i], leg_y_pos[i] - 0.2])
        legs[i+3].set_3d_properties([-0.1, -0.6 + 0.1 * np.sin(t)])

    # f. Update Antennae
    ant_l.set_data([-0.1, -0.5], [1.4, 1.9])
    ant_l.set_3d_properties([0.1, 0.6])
    ant_r.set_data([0.1, 0.5], [1.4, 1.9])
    ant_r.set_3d_properties([0.1, 0.6])

    return legs + [ant_l, ant_r]

# 5. Final Setup
ax.set_xlim(-4, 4)
ax.set_ylim(-4, 4)
ax.set_zlim(-3, 3)
ax.grid(True, alpha=0.2)

ani = FuncAnimation(fig, update, frames=100, interval=50, blit=False)

plt.close()
HTML(ani.to_jshtml())